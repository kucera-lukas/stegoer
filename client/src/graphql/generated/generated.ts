import gql from "graphql-tag";
import * as Urql from "urql";
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>;
};
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  Cursor: any;
  Time: any;
  Upload: any;
};

export type Auth = {
  __typename?: "Auth";
  expires: Scalars["Time"];
  token: Scalars["String"];
};

export enum Channel {
  Blue = "BLUE",
  Green = "GREEN",
  GreenBlue = "GREEN_BLUE",
  Red = "RED",
  RedBlue = "RED_BLUE",
  RedGreen = "RED_GREEN",
  RedGreenBlue = "RED_GREEN_BLUE",
}

export type CreateImagePayload = {
  __typename?: "CreateImagePayload";
  errors: Array<Error>;
  image?: Maybe<Image>;
};

export type CreateUserPayload = {
  __typename?: "CreateUserPayload";
  auth?: Maybe<Auth>;
  errors: Array<Error>;
  user?: Maybe<User>;
};

export type Error = {
  __typename?: "Error";
  code: ErrorCode;
  message: Scalars["String"];
  path: Scalars["String"];
};

export enum ErrorCode {
  AuthorizationError = "AUTHORIZATION_ERROR",
  BadRequestError = "BAD_REQUEST_ERROR",
  DbError = "DB_ERROR",
  GraphqlError = "GRAPHQL_ERROR",
  InternalServerError = "INTERNAL_SERVER_ERROR",
  NotFoundError = "NOT_FOUND_ERROR",
  ValidationError = "VALIDATION_ERROR",
}

export type Image = Node & {
  __typename?: "Image";
  channel: Channel;
  createdAt: Scalars["Time"];
  id: Scalars["ID"];
  updatedAt: Scalars["Time"];
};

export type ImageEdge = {
  __typename?: "ImageEdge";
  cursor: Scalars["Cursor"];
  node: Image;
};

export type ImageOrder = {
  direction: OrderDirection;
  field?: InputMaybe<ImageOrderField>;
};

export enum ImageOrderField {
  CreatedAt = "CREATED_AT",
  UpdatedAt = "UPDATED_AT",
}

/**
 * ImageWhereInput is used for filtering DisplayImage objects.
 * Input was generated by ent.
 */
export type ImageWhereInput = {
  and?: InputMaybe<Array<ImageWhereInput>>;
  /** channel field predicates */
  channel?: InputMaybe<Channel>;
  channelIn?: InputMaybe<Array<Channel>>;
  channelNEQ?: InputMaybe<Channel>;
  channelNotIn?: InputMaybe<Array<Channel>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars["Time"]>;
  createdAtGT?: InputMaybe<Scalars["Time"]>;
  createdAtGTE?: InputMaybe<Scalars["Time"]>;
  createdAtIn?: InputMaybe<Array<Scalars["Time"]>>;
  createdAtLT?: InputMaybe<Scalars["Time"]>;
  createdAtLTE?: InputMaybe<Scalars["Time"]>;
  createdAtNEQ?: InputMaybe<Scalars["Time"]>;
  createdAtNotIn?: InputMaybe<Array<Scalars["Time"]>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars["Boolean"]>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars["ID"]>;
  idGT?: InputMaybe<Scalars["ID"]>;
  idGTE?: InputMaybe<Scalars["ID"]>;
  idIn?: InputMaybe<Array<Scalars["ID"]>>;
  idLT?: InputMaybe<Scalars["ID"]>;
  idLTE?: InputMaybe<Scalars["ID"]>;
  idNEQ?: InputMaybe<Scalars["ID"]>;
  idNotIn?: InputMaybe<Array<Scalars["ID"]>>;
  not?: InputMaybe<ImageWhereInput>;
  or?: InputMaybe<Array<ImageWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars["Time"]>;
  updatedAtGT?: InputMaybe<Scalars["Time"]>;
  updatedAtGTE?: InputMaybe<Scalars["Time"]>;
  updatedAtIn?: InputMaybe<Array<Scalars["Time"]>>;
  updatedAtLT?: InputMaybe<Scalars["Time"]>;
  updatedAtLTE?: InputMaybe<Scalars["Time"]>;
  updatedAtNEQ?: InputMaybe<Scalars["Time"]>;
  updatedAtNotIn?: InputMaybe<Array<Scalars["Time"]>>;
};

export type ImagesPayload = {
  __typename?: "ImagesPayload";
  edges: Array<ImageEdge>;
  errors: Array<Error>;
  pageInfo?: Maybe<PageInfo>;
  totalCount?: Maybe<Scalars["Int"]>;
};

export type Login = {
  password: Scalars["String"];
  username: Scalars["String"];
};

export type LoginPayload = {
  __typename?: "LoginPayload";
  auth?: Maybe<Auth>;
  errors: Array<Error>;
  user?: Maybe<User>;
};

export type Mutation = {
  __typename?: "Mutation";
  createImage: CreateImagePayload;
  createUser: CreateUserPayload;
  login: LoginPayload;
  refreshToken: RefreshTokenPayload;
  updateUser: UpdateUserPayload;
};

export type MutationCreateImageArgs = {
  input: NewImage;
};

export type MutationCreateUserArgs = {
  input: NewUser;
};

export type MutationLoginArgs = {
  input: Login;
};

export type MutationRefreshTokenArgs = {
  input: RefreshTokenInput;
};

export type MutationUpdateUserArgs = {
  input: UpdateUser;
};

export type NewImage = {
  channel: Channel;
  file: Scalars["Upload"];
};

export type NewUser = {
  password: Scalars["String"];
  username: Scalars["String"];
};

export type Node = {
  id: Scalars["ID"];
};

export enum OrderDirection {
  Asc = "ASC",
  Desc = "DESC",
}

export type OverviewPayload = {
  __typename?: "OverviewPayload";
  errors: Array<Error>;
  user?: Maybe<User>;
};

export type PageInfo = {
  __typename?: "PageInfo";
  endCursor?: Maybe<Scalars["Cursor"]>;
  hasNextPage: Scalars["Boolean"];
  hasPreviousPage: Scalars["Boolean"];
  startCursor?: Maybe<Scalars["Cursor"]>;
};

export type Query = {
  __typename?: "Query";
  images: ImagesPayload;
  overview: OverviewPayload;
};

export type QueryImagesArgs = {
  after?: InputMaybe<Scalars["Cursor"]>;
  before?: InputMaybe<Scalars["Cursor"]>;
  first?: InputMaybe<Scalars["Int"]>;
  last?: InputMaybe<Scalars["Int"]>;
  orderBy?: InputMaybe<ImageOrder>;
  where?: InputMaybe<ImageWhereInput>;
};

export type RefreshTokenInput = {
  token: Scalars["String"];
};

export type RefreshTokenPayload = {
  __typename?: "RefreshTokenPayload";
  auth?: Maybe<Auth>;
  errors: Array<Error>;
  user?: Maybe<User>;
};

export type UpdateUser = {
  name?: InputMaybe<Scalars["String"]>;
  password?: InputMaybe<Scalars["String"]>;
};

export type UpdateUserPayload = {
  __typename?: "UpdateUserPayload";
  errors: Array<Error>;
  user?: Maybe<User>;
};

export type User = {
  __typename?: "User";
  createdAt: Scalars["Time"];
  id: Scalars["ID"];
  name: Scalars["String"];
  updatedAt: Scalars["Time"];
};

/**
 * UserWhereInput is used for filtering User objects.
 * Input was generated by ent.
 */
export type UserWhereInput = {
  and?: InputMaybe<Array<UserWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars["Time"]>;
  createdAtGT?: InputMaybe<Scalars["Time"]>;
  createdAtGTE?: InputMaybe<Scalars["Time"]>;
  createdAtIn?: InputMaybe<Array<Scalars["Time"]>>;
  createdAtLT?: InputMaybe<Scalars["Time"]>;
  createdAtLTE?: InputMaybe<Scalars["Time"]>;
  createdAtNEQ?: InputMaybe<Scalars["Time"]>;
  createdAtNotIn?: InputMaybe<Array<Scalars["Time"]>>;
  /** images edge predicates */
  hasImages?: InputMaybe<Scalars["Boolean"]>;
  hasImagesWith?: InputMaybe<Array<ImageWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars["ID"]>;
  idGT?: InputMaybe<Scalars["ID"]>;
  idGTE?: InputMaybe<Scalars["ID"]>;
  idIn?: InputMaybe<Array<Scalars["ID"]>>;
  idLT?: InputMaybe<Scalars["ID"]>;
  idLTE?: InputMaybe<Scalars["ID"]>;
  idNEQ?: InputMaybe<Scalars["ID"]>;
  idNotIn?: InputMaybe<Array<Scalars["ID"]>>;
  /** name field predicates */
  name?: InputMaybe<Scalars["String"]>;
  nameContains?: InputMaybe<Scalars["String"]>;
  nameContainsFold?: InputMaybe<Scalars["String"]>;
  nameEqualFold?: InputMaybe<Scalars["String"]>;
  nameGT?: InputMaybe<Scalars["String"]>;
  nameGTE?: InputMaybe<Scalars["String"]>;
  nameHasPrefix?: InputMaybe<Scalars["String"]>;
  nameHasSuffix?: InputMaybe<Scalars["String"]>;
  nameIn?: InputMaybe<Array<Scalars["String"]>>;
  nameLT?: InputMaybe<Scalars["String"]>;
  nameLTE?: InputMaybe<Scalars["String"]>;
  nameNEQ?: InputMaybe<Scalars["String"]>;
  nameNotIn?: InputMaybe<Array<Scalars["String"]>>;
  not?: InputMaybe<UserWhereInput>;
  or?: InputMaybe<Array<UserWhereInput>>;
  /** password field predicates */
  password?: InputMaybe<Scalars["String"]>;
  passwordContains?: InputMaybe<Scalars["String"]>;
  passwordContainsFold?: InputMaybe<Scalars["String"]>;
  passwordEqualFold?: InputMaybe<Scalars["String"]>;
  passwordGT?: InputMaybe<Scalars["String"]>;
  passwordGTE?: InputMaybe<Scalars["String"]>;
  passwordHasPrefix?: InputMaybe<Scalars["String"]>;
  passwordHasSuffix?: InputMaybe<Scalars["String"]>;
  passwordIn?: InputMaybe<Array<Scalars["String"]>>;
  passwordLT?: InputMaybe<Scalars["String"]>;
  passwordLTE?: InputMaybe<Scalars["String"]>;
  passwordNEQ?: InputMaybe<Scalars["String"]>;
  passwordNotIn?: InputMaybe<Array<Scalars["String"]>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars["Time"]>;
  updatedAtGT?: InputMaybe<Scalars["Time"]>;
  updatedAtGTE?: InputMaybe<Scalars["Time"]>;
  updatedAtIn?: InputMaybe<Array<Scalars["Time"]>>;
  updatedAtLT?: InputMaybe<Scalars["Time"]>;
  updatedAtLTE?: InputMaybe<Scalars["Time"]>;
  updatedAtNEQ?: InputMaybe<Scalars["Time"]>;
  updatedAtNotIn?: InputMaybe<Array<Scalars["Time"]>>;
};

export type ErrorFragmentFragment = {
  __typename?: "Error";
  message: string;
  code: ErrorCode;
  path: string;
};

export type PageInfoFragmentFragment = {
  __typename?: "PageInfo";
  hasNextPage: boolean;
  endCursor?: any | null;
};

export type ImageFragmentFragment = {
  __typename?: "Image";
  id: string;
  channel: Channel;
  createdAt: any;
  updatedAt: any;
};

export type AuthFragmentFragment = {
  __typename?: "Auth";
  token: string;
  expires: any;
};

export type UserFragmentFragment = {
  __typename?: "User";
  id: string;
  name: string;
  createdAt: any;
  updatedAt: any;
};

export type CreateImageMutationVariables = Exact<{
  channel: Channel;
  file: Scalars["Upload"];
}>;

export type CreateImageMutation = {
  __typename?: "Mutation";
  createImage: {
    __typename?: "CreateImagePayload";
    image?: {
      __typename?: "Image";
      id: string;
      channel: Channel;
      createdAt: any;
      updatedAt: any;
    } | null;
    errors: Array<{
      __typename?: "Error";
      message: string;
      code: ErrorCode;
      path: string;
    }>;
  };
};

export type ImagesQueryVariables = Exact<{
  after?: InputMaybe<Scalars["Cursor"]>;
  first?: InputMaybe<Scalars["Int"]>;
  before?: InputMaybe<Scalars["Cursor"]>;
  last?: InputMaybe<Scalars["Int"]>;
  where?: InputMaybe<ImageWhereInput>;
  orderBy?: InputMaybe<ImageOrder>;
}>;

export type ImagesQuery = {
  __typename?: "Query";
  images: {
    __typename?: "ImagesPayload";
    totalCount?: number | null;
    edges: Array<{
      __typename?: "ImageEdge";
      node: {
        __typename?: "Image";
        id: string;
        channel: Channel;
        createdAt: any;
        updatedAt: any;
      };
    }>;
    pageInfo?: {
      __typename?: "PageInfo";
      hasNextPage: boolean;
      endCursor?: any | null;
    } | null;
    errors: Array<{
      __typename?: "Error";
      message: string;
      code: ErrorCode;
      path: string;
    }>;
  };
};

export type CreateUserMutationVariables = Exact<{
  username: Scalars["String"];
  password: Scalars["String"];
}>;

export type CreateUserMutation = {
  __typename?: "Mutation";
  createUser: {
    __typename?: "CreateUserPayload";
    user?: {
      __typename?: "User";
      id: string;
      name: string;
      createdAt: any;
      updatedAt: any;
    } | null;
    auth?: { __typename?: "Auth"; token: string; expires: any } | null;
    errors: Array<{
      __typename?: "Error";
      message: string;
      code: ErrorCode;
      path: string;
    }>;
  };
};

export type OverviewQueryVariables = Exact<{ [key: string]: never }>;

export type OverviewQuery = {
  __typename?: "Query";
  overview: {
    __typename?: "OverviewPayload";
    user?: {
      __typename?: "User";
      id: string;
      name: string;
      createdAt: any;
      updatedAt: any;
    } | null;
    errors: Array<{
      __typename?: "Error";
      message: string;
      code: ErrorCode;
      path: string;
    }>;
  };
};

export type RefreshTokenMutationVariables = Exact<{
  token: Scalars["String"];
}>;

export type RefreshTokenMutation = {
  __typename?: "Mutation";
  refreshToken: {
    __typename?: "RefreshTokenPayload";
    user?: {
      __typename?: "User";
      id: string;
      name: string;
      createdAt: any;
      updatedAt: any;
    } | null;
    auth?: { __typename?: "Auth"; token: string; expires: any } | null;
    errors: Array<{
      __typename?: "Error";
      message: string;
      code: ErrorCode;
      path: string;
    }>;
  };
};

export type UpdateUserMutationVariables = Exact<{
  name?: InputMaybe<Scalars["String"]>;
  password?: InputMaybe<Scalars["String"]>;
}>;

export type UpdateUserMutation = {
  __typename?: "Mutation";
  updateUser: {
    __typename?: "UpdateUserPayload";
    user?: {
      __typename?: "User";
      id: string;
      name: string;
      createdAt: any;
      updatedAt: any;
    } | null;
    errors: Array<{
      __typename?: "Error";
      message: string;
      code: ErrorCode;
      path: string;
    }>;
  };
};

export const ErrorFragmentFragmentDoc = gql`
  fragment ErrorFragment on Error {
    message
    code
    path
  }
`;
export const PageInfoFragmentFragmentDoc = gql`
  fragment PageInfoFragment on PageInfo {
    hasNextPage
    endCursor
  }
`;
export const ImageFragmentFragmentDoc = gql`
  fragment ImageFragment on Image {
    id
    channel
    createdAt
    updatedAt
  }
`;
export const AuthFragmentFragmentDoc = gql`
  fragment AuthFragment on Auth {
    token
    expires
  }
`;
export const UserFragmentFragmentDoc = gql`
  fragment UserFragment on User {
    id
    name
    createdAt
    updatedAt
  }
`;
export const CreateImageDocument = gql`
  mutation createImage($channel: Channel!, $file: Upload!) {
    createImage(input: { channel: $channel, file: $file }) {
      image {
        ...ImageFragment
      }
      errors {
        ...ErrorFragment
      }
    }
  }
  ${ImageFragmentFragmentDoc}
  ${ErrorFragmentFragmentDoc}
`;

export function useCreateImageMutation() {
  return Urql.useMutation<CreateImageMutation, CreateImageMutationVariables>(
    CreateImageDocument,
  );
}
export const ImagesDocument = gql`
  query images(
    $after: Cursor
    $first: Int
    $before: Cursor
    $last: Int
    $where: ImageWhereInput
    $orderBy: ImageOrder
  ) {
    images(
      after: $after
      first: $first
      before: $before
      last: $last
      where: $where
      orderBy: $orderBy
    ) {
      totalCount
      edges {
        node {
          ...ImageFragment
        }
      }
      pageInfo {
        ...PageInfoFragment
      }
      errors {
        ...ErrorFragment
      }
    }
  }
  ${ImageFragmentFragmentDoc}
  ${PageInfoFragmentFragmentDoc}
  ${ErrorFragmentFragmentDoc}
`;

export function useImagesQuery(
  options?: Omit<Urql.UseQueryArgs<ImagesQueryVariables>, "query">,
) {
  return Urql.useQuery<ImagesQuery>({ query: ImagesDocument, ...options });
}
export const CreateUserDocument = gql`
  mutation createUser($username: String!, $password: String!) {
    createUser(input: { username: $username, password: $password }) {
      user {
        ...UserFragment
      }
      auth {
        ...AuthFragment
      }
      errors {
        ...ErrorFragment
      }
    }
  }
  ${UserFragmentFragmentDoc}
  ${AuthFragmentFragmentDoc}
  ${ErrorFragmentFragmentDoc}
`;

export function useCreateUserMutation() {
  return Urql.useMutation<CreateUserMutation, CreateUserMutationVariables>(
    CreateUserDocument,
  );
}
export const OverviewDocument = gql`
  query overview {
    overview {
      user {
        ...UserFragment
      }
      errors {
        ...ErrorFragment
      }
    }
  }
  ${UserFragmentFragmentDoc}
  ${ErrorFragmentFragmentDoc}
`;

export function useOverviewQuery(
  options?: Omit<Urql.UseQueryArgs<OverviewQueryVariables>, "query">,
) {
  return Urql.useQuery<OverviewQuery>({ query: OverviewDocument, ...options });
}
export const RefreshTokenDocument = gql`
  mutation refreshToken($token: String!) {
    refreshToken(input: { token: $token }) {
      user {
        ...UserFragment
      }
      auth {
        ...AuthFragment
      }
      errors {
        ...ErrorFragment
      }
    }
  }
  ${UserFragmentFragmentDoc}
  ${AuthFragmentFragmentDoc}
  ${ErrorFragmentFragmentDoc}
`;

export function useRefreshTokenMutation() {
  return Urql.useMutation<RefreshTokenMutation, RefreshTokenMutationVariables>(
    RefreshTokenDocument,
  );
}
export const UpdateUserDocument = gql`
  mutation updateUser($name: String, $password: String) {
    updateUser(input: { name: $name, password: $password }) {
      user {
        ...UserFragment
      }
      errors {
        ...ErrorFragment
      }
    }
  }
  ${UserFragmentFragmentDoc}
  ${ErrorFragmentFragmentDoc}
`;

export function useUpdateUserMutation() {
  return Urql.useMutation<UpdateUserMutation, UpdateUserMutationVariables>(
    UpdateUserDocument,
  );
}
